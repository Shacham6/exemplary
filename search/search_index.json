{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Exemplary \u00b6 Exemplary is a tool which provides extremely simple way to generate markdown documentation from actual source code examples!","title":"Exemplary"},{"location":"#exemplary","text":"Exemplary is a tool which provides extremely simple way to generate markdown documentation from actual source code examples!","title":"Exemplary"},{"location":"1_gen_scanner/","text":"Scanner \u00b6 The scanner is a simple module - it's the one that reads source code files, and outputs what's known as \"Segments\". Let's look at an example. Consider a file with the following content: 1 2 3 # @start md # Content # @end Those @start and @end annotate the start & end of blocks . The md that comes after the @start specify the processor that will handle the block . In this case it'll be the raw markdown processor. Using the scanner on the aforementioned file will result in Segments being formed. See here: 1 2 3 from exemplary.scanner import scan segments = list ( scan ( text )) Note Calling list(...) here since the scan method returns a generator. This specific text will yield only a single segment, which will be the following: 1 2 3 4 5 6 Segment ( processor = \"md\" , args = {}, document = \"# Content\" , comment_pat = \"#\" , ) Agnostic Comments Support \u00b6 Although in the previous example the annotations where inside a Python-like comment ( # ), all comment-styles are natively supported. For example, here's a document with C-style comment: 1 2 3 // @start md // Content // @end Scanning it will yield the same segment as in the previous example, only with a different comment_pat field: 1 2 3 4 5 6 7 8 9 segments = list ( scan ( text )) assert segments == [ Segment ( processor = \"md\" , args = {}, document = \"Content\" , comment_pat = \"//\" , ) ]","title":"Scanner"},{"location":"1_gen_scanner/#scanner","text":"The scanner is a simple module - it's the one that reads source code files, and outputs what's known as \"Segments\". Let's look at an example. Consider a file with the following content: 1 2 3 # @start md # Content # @end Those @start and @end annotate the start & end of blocks . The md that comes after the @start specify the processor that will handle the block . In this case it'll be the raw markdown processor. Using the scanner on the aforementioned file will result in Segments being formed. See here: 1 2 3 from exemplary.scanner import scan segments = list ( scan ( text )) Note Calling list(...) here since the scan method returns a generator. This specific text will yield only a single segment, which will be the following: 1 2 3 4 5 6 Segment ( processor = \"md\" , args = {}, document = \"# Content\" , comment_pat = \"#\" , )","title":"Scanner"},{"location":"1_gen_scanner/#agnostic-comments-support","text":"Although in the previous example the annotations where inside a Python-like comment ( # ), all comment-styles are natively supported. For example, here's a document with C-style comment: 1 2 3 // @start md // Content // @end Scanning it will yield the same segment as in the previous example, only with a different comment_pat field: 1 2 3 4 5 6 7 8 9 segments = list ( scan ( text )) assert segments == [ Segment ( processor = \"md\" , args = {}, document = \"Content\" , comment_pat = \"//\" , ) ]","title":"Agnostic Comments Support"}]}